// Generated by CoffeeScript 1.4.0

/*
  @author Mikk Kirstein http://www.github.com/kirstein

  An implementation of Publish/Subscribe pattern.
  Contains following methods:
    1. #subscribe(event, callback, [context])
    2. #unsubscribe([event], [callback])
    3. #publish(event, [args...])
    4. #once(event, callback, [context])
*/


(function() {
  var PubSub,
    __slice = [].slice;

  PubSub = (function() {

    function PubSub() {
      this._pubsub = {};
    }

    PubSub.prototype.subscribe = function(event, callback, context) {
      var callb, _base;
      if (typeof event === 'undefined') {
        throw new Error("No event defined");
      }
      if (typeof callback !== 'function') {
        throw new Error("No callback defined");
      }
      callb = {
        callback: callback,
        context: context || this
      };
      (_base = this._pubsub)[event] || (_base[event] = []);
      this._pubsub[event].push(callb);
      return this;
    };

    PubSub.prototype.unsubscribe = function(event, callback) {
      var callb, callbacks, i, _i, _ref;
      if (typeof event === 'undefined' && typeof callback === 'undefined') {
        this._pubsub = {};
      }
      if (typeof callback === 'undefined') {
        delete this._pubsub[event];
      }
      callbacks = this._pubsub[event] || [];
      for (i = _i = _ref = callbacks.length - 1; _ref <= -1 ? _i < -1 : _i > -1; i = _ref <= -1 ? ++_i : --_i) {
        callb = callbacks[i].callback;
        if (callb._original) {
          callb = callb._original;
        }
        if (callb === callback) {
          callbacks.splice(i, 1);
        }
      }
      return this;
    };

    PubSub.prototype.publish = function() {
      var args, callb, callback, callbacks, event, _i, _len;
      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (typeof event === 'undefined') {
        throw new Error("No event defined");
      }
      callbacks = this._pubsub[event] || [];
      for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
        callb = callbacks[_i];
        callback = callb.callback;
        callback.apply(callb.context, args);
      }
      return this;
    };

    PubSub.prototype.once = function(event, callback, context) {
      var wrapped;
      if (typeof event === 'undefined') {
        throw new Error("No event defined");
      }
      if (typeof callback !== 'function') {
        throw new Error("No callback defined");
      }
      wrapped = function() {
        delete wrapped._original;
        this.unsubscribe(event, wrapped);
        return callback.apply(context, arguments);
      };
      wrapped._original = callback;
      return this.subscribe(event, wrapped, this);
    };

    PubSub.prototype.on = PubSub.prototype.subscribe;

    PubSub.prototype.off = PubSub.prototype.unsubscribe;

    PubSub.prototype.trigger = PubSub.prototype.publish;

    return PubSub;

  })();

  if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
    define(function() {
      return PubSub;
    });
  } else if (typeof module === 'object' && module && module.exports) {
    module.exports = PubSub;
  }

}).call(this);
